var documenterSearchIndex = {"docs":
[{"location":"rates/#Estimating-fixation-and-polymorphic-rates-considering-generalized-model-of-selection-and-linkage-1","page":"Rates","title":"Estimating fixation and polymorphic rates considering generalized model of selection and linkage","text":"","category":"section"},{"location":"analytical/#Analytical-estimation-1","page":"Analytical estimations","title":"Analytical estimation","text":"","category":"section"},{"location":"analytical/#Solving-\\alpha_{(x)}-1","page":"Analytical estimations","title":"Solving alpha_(x)","text":"","category":"section"},{"location":"analytical/#","page":"Analytical estimations","title":"Analytical estimations","text":"Our method is based in the analytical solution of alpha_(x) given a genetic scenario. The method could be extended to any DFE and background selection values in order to get summary statistics that can be used at ABC methods. In this example we show how the asympotic alpha is affected by linkage and background selection.","category":"page"},{"location":"analytical/#","page":"Analytical estimations","title":"Analytical estimations","text":"Before start you need to set up a variable of type Analytical.parameters. It is a Mutable structure containing the parameters required to solve the analytical approach. Any value can be easily changed. Remember that the variable should be defined before the execution, in other case, alpha_(x) will be solve with default values. To change all the values at once, just check the variables at the struct Analytical.parameters in order to set specific models.","category":"page"},{"location":"analytical/#Load-the-modules-1","page":"Analytical estimations","title":"Load the modules","text":"","category":"section"},{"location":"analytical/#","page":"Analytical estimations","title":"Analytical estimations","text":"using Analytical","category":"page"},{"location":"analytical/#Setting-model-parameters-and-convolute-the-binomial-distribution.-1","page":"Analytical estimations","title":"Setting model parameters and convolute the binomial distribution.","text":"","category":"section"},{"location":"analytical/#","page":"Analytical estimations","title":"Analytical estimations","text":"We set a global adaptation rate of 0.4 with a contribution of 0.2 regarding weak adaptation. The process is modeled using selection coefficient of 500,10 for strongly and weakly beneficial alleles. We modeled the DFE for deleterious alleles using the values provided at Boyko et al. (2008). ","category":"page"},{"location":"analytical/#","page":"Analytical estimations","title":"Analytical estimations","text":"adap = Analytical.parameters(n=661,alTot=0.4,alLow=0.2,gH=500,gamNeg=-457,al=0.184,be = 0.184/457,B=0.999)","category":"page"},{"location":"analytical/#","page":"Analytical estimations","title":"Analytical estimations","text":"Before solve the model, you must compute the convoluted binomial distribution to subset the expected SFS","category":"page"},{"location":"analytical/#","page":"Analytical estimations","title":"Analytical estimations","text":"convolutedSamples = Analytical.binomialDict()\nAnalytical.binomOp!(adap,convolutedSamples.bn)","category":"page"},{"location":"analytical/#Solving-the-model-1","page":"Analytical estimations","title":"Solving the model","text":"","category":"section"},{"location":"analytical/#","page":"Analytical estimations","title":"Analytical estimations","text":"Here we solve alpha_(x) generally, using the expected rates. We are not considering any specific mutation process over a locus and branch time.","category":"page"},{"location":"analytical/#","page":"Analytical estimations","title":"Analytical estimations","text":"alpha_(x)","category":"page"},{"location":"analytical/#","page":"Analytical estimations","title":"Analytical estimations","text":"is solved using the fixation and polymorphic rates since the locus length (L) and the time branch (T) estimations at first order alpha_(x) estimation can be cancelled","category":"page"},{"location":"analytical/#","page":"Analytical estimations","title":"Analytical estimations","text":"mathbbEalpha_(x) approx 1 - fracLT(mathbbEd_S)LT(mathbbEd_N) fracLT(mathbbEp_S(x))LT(mathbbEp_N(x)) approx 1 - fracmathbbEd_SmathbbEd_N fracmathbbEp_S(x)mathbbEp_N(x)","category":"page"},{"location":"analytical/#","page":"Analytical estimations","title":"Analytical estimations","text":"where fracLTLT with a constant mutation rate tend to 1. ","category":"page"},{"location":"analytical/#","page":"Analytical estimations","title":"Analytical estimations","text":"x,y = Analytical.analyticalAlpha(param = adap, convolutedSamples = convolutedSamples)","category":"page"},{"location":"analytical/#","page":"Analytical estimations","title":"Analytical estimations","text":"Internally the function (1) set the mutation rate regarding the BGS strenght and (2) set the probability of fixations given the genetic scenario. Then, it estimates the SFS and fixations rates for neutral and non-neutral alleles. Please check analyticalAlpha to check the process.","category":"page"},{"location":"analytical/#Plotting-the-results.-1","page":"Analytical estimations","title":"Plotting the results.","text":"","category":"section"},{"location":"analytical/#","page":"Analytical estimations","title":"Analytical estimations","text":"x","category":"page"},{"location":"analytical/#","page":"Analytical estimations","title":"Analytical estimations","text":"contains alpha_(x) accounting for weakly beneficial alleles. y contains the value of alpha_(x), not accounting for weakly beneficial alleles. In this example, we do not model BGS (check B parameter in Analytical.parameters function above)","category":"page"},{"location":"analytical/#","page":"Analytical estimations","title":"Analytical estimations","text":"In Julia you can easily use R using the module RCall. Please check you have installed R in your system. Nonetheless you can plot using Julia Plots module.","category":"page"},{"location":"analytical/#","page":"Analytical estimations","title":"Analytical estimations","text":"If you are using our Docker or Singularity image, you don't need to install anything. In other case, install RCall just in case you want to plot using R","category":"page"},{"location":"analytical/#","page":"Analytical estimations","title":"Analytical estimations","text":"using Pkg\nPkg.add(\"RCall\")","category":"page"},{"location":"analytical/#","page":"Analytical estimations","title":"Analytical estimations","text":"using RCall\n\nR\"\"\"\n\tlibrary(ggplot2)\n\tlibrary(reshape2)\n\tdf = data.frame(f=seq(1,length($x)),x=$x,y=$y)\n\td  = melt(df,id.vars='f')\n\tp = ggplot(df,aes(x=f,y=value,color=variable)) + geom_line() + geom_point() + scale_colour_manual(values=c('#30504f', '#e2bd9a'),labels = c(\"Nuetral + deleterious alleles\", \"All alleles\")) + theme_bw()\n\tp\n\"\"\"","category":"page"},{"location":"analytical/#","page":"Analytical estimations","title":"Analytical estimations","text":"(Image: image)","category":"page"},{"location":"data/#Parsing-genomic-data-1","page":"Processing data","title":"Parsing genomic data","text":"","category":"section"},{"location":"data/#","page":"Processing data","title":"Processing data","text":"The module include functions to parse TGP from Uricchio et al. (2019) and DGN from Murga-Moreno et al. (2019). In addition we include a function to parse SFS and divergence from multi-FASTA data following Murga-Moreno et al. (2019)","category":"page"},{"location":"data/#","page":"Processing data","title":"Processing data","text":"Please to parse raw data into SFS and divergence counts, first download raw files deposited in our repository: \t- TGP \t- DGN Zambia population \t- DGN Raleigh population","category":"page"},{"location":"data/#","page":"Processing data","title":"Processing data","text":"Once you have downloaded the files you can use the function Analytical.parseSfs to convert the data into SFS and divergence counts. Please check Analytical.parseSfs to get more info.","category":"page"},{"location":"data/#","page":"Processing data","title":"Processing data","text":"alpha, sfs, divergence = Analytical.parseSfs(sampleSize = 661, data = \"/home/jmurga/tgp.txt\")","category":"page"},{"location":"data/#","page":"Processing data","title":"Processing data","text":"To save the data you can use CSV and DataFrames packages","category":"page"},{"location":"data/#","page":"Processing data","title":"Processing data","text":"using CSV, DataFrames\nCSV.write(\"/home/jmurga/tgpSfs.tsv\",DataFrame(sfs),delim='\\t')\nCSV.write(\"/home/jmurga/tgpDiv.tsv\",DataFrame(permutedims(divergence)),delim='\\t')","category":"page"},{"location":"data/#","page":"Processing data","title":"Processing data","text":"It is possible to directly subset the gene IDs using Ensembl or Flybase id. Use the argument geneList inputing an string array","category":"page"},{"location":"data/#","page":"Processing data","title":"Processing data","text":"ensemblList = CSV.read(\"/home/jmurga/ensemblList.txt\",header=false,DataFrame) |> Array\n\nalpha, sfs, divergence = Analytical.parseSfs(sampleSize = 661, data = \"/home/jmurga/tgp.txt\",geneList = ensemblList)","category":"page"},{"location":"data/#","page":"Processing data","title":"Processing data","text":"If you are going to parse DGN, you need to change the value of the argument isoline to true. Following the Murga-Moreno et al. (2019) sample size for each population are:","category":"page"},{"location":"data/#","page":"Processing data","title":"Processing data","text":"Zambia population: 154\nRAL population: 160","category":"page"},{"location":"data/#","page":"Processing data","title":"Processing data","text":"alpha, sfs, divergence = Analytical.parseSfs(sampleSize = 160, data = \"/home/jmurga/dgnRal.txt\",isolines=true)","category":"page"},{"location":"data/#","page":"Processing data","title":"Processing data","text":"##Processing muti-FASTA files We included some tools to process multi-FASTA files into unfolded SFS and divergence. The function Analytical.uSfsFromFasta need three files: a reference file to degenerate the sequence, a multi-FASTA file to process the polymorphism and a outgroup sequence to process the divergence. Consider to download DGN data from Pool lab or PopFly to obtain this files.","category":"page"},{"location":"data/#","page":"Processing data","title":"Processing data","text":"<!-- sfs, div = Analytical.uSfsFromFasta(\n                        file = \"/home/jmurga/Downloads/example.fa\",\n                        reference  = \"/home/jmurga/Downloads/ref.fa\",\n                        outgroup   = \"/home/jmurga/Downloads/outgroups.fa\",\n                        samples    = 160,\n                        bins       = 20,\n                        codonTable = \"standard\"\n                     ) -->","category":"page"},{"location":"data/#","page":"Processing data","title":"Processing data","text":"The scripts transforms a multi-FASTA file into a matrix which eliminates the monomorphic sites and process the divergent and polymorphic sites. Only 0-fold and 4-fold sites are analyzed as proxy of neutral and selected alleles. The following matrix correspond to the matrix processed at the above example.","category":"page"},{"location":"data/#","page":"Processing data","title":"Processing data","text":"<!-- 162×153456 Array{Char,2}:\n '0'  '0'  '0'  '0'  '0'  '0'  '4'  …  '0'  '0'  '4'  '0'  '0'  '0'\n 'A'  'A'  'G'  'A'  'C'  'C'  'T'     'G'  'G'  'C'  'A'  'G'  'T'\n 'A'  'A'  'G'  'A'  'C'  'C'  'T'     'G'  'G'  'C'  'A'  'G'  'T'\n 'A'  'A'  'G'  'A'  'C'  'C'  'T'     'G'  'G'  'C'  'A'  'G'  'T'\n 'A'  'A'  'G'  'A'  'C'  'C'  'T'     'G'  'G'  'C'  'A'  'G'  'T'\n 'A'  'A'  'G'  'A'  'C'  'C'  'T'  …  'G'  'G'  'C'  'A'  'G'  'T'\n 'A'  'A'  'G'  'A'  'C'  'C'  'T'     'G'  'G'  'C'  'A'  'G'  'T'\n 'A'  'A'  'G'  'A'  'C'  'C'  'T'     'G'  'G'  'C'  'A'  'G'  'T'\n ⋮                        ⋮         ⋱  ⋮                        ⋮\n 'A'  'A'  'G'  'A'  'C'  'C'  'T'     'G'  'G'  'C'  'A'  'G'  'T'\n 'A'  'A'  'G'  'A'  'C'  'C'  'T'  …  'G'  'G'  'C'  'A'  'G'  'T'\n 'A'  'A'  'G'  'A'  'C'  'C'  'T'     'G'  'G'  'C'  'A'  'G'  'T'\n 'A'  'A'  'G'  'A'  'C'  'C'  'T'     'G'  'G'  'C'  'A'  'G'  'T'\n 'A'  'A'  'G'  'A'  'C'  'C'  'T'     'G'  'G'  'C'  'A'  'G'  'T'\n 'A'  'A'  'G'  'A'  'C'  'C'  'T'     'G'  'G'  'C'  'A'  'G'  'T'\n 'A'  'A'  'G'  'A'  'C'  'C'  'T'  …  'G'  'G'  'C'  'A'  'G'  'T'\n 'A'  'A'  'G'  'C'  'C'  'A'  'T'     'G'  'G'  'C'  'A'  'G'  'T' -->","category":"page"},{"location":"data/#","page":"Processing data","title":"Processing data","text":"Each column correspond to a sample position. Only fixed divergence and biallelic sites are process. The matrix is iterated through columns to discard the rest of the cases. The matrix is iterated to check the columns independently. In this way we check fixed divergence or biallelic polymorphism. For example at the following array all polymorphic positions (from row 2 to row 161) correspond to 'A' nucleotides where as the outgroup (last row) correspond to 'G'. This columns is addedas to neutral or selected divergence depedending on the first row value:","category":"page"},{"location":"data/#","page":"Processing data","title":"Processing data","text":"<!-- 162×1 Array{Char,1}:\n '0'\n 'A'\n 'A'\n 'A'\n 'A'\n 'A'\n 'A'\n 'A'\n ⋮  \n 'A'\n 'A'\n 'A'\n 'A'\n 'A'\n 'A'\n 'A'\n 'C' -->","category":"page"},{"location":"data/#","page":"Processing data","title":"Processing data","text":"The next example represent one polymorphic site taking into account the derived allele. At this array, the first 3 polymorphic positions correspond to 'G' where as the rest of polymorphic sites correspond to C. Since 'C' is the ancestral nucleotide (last row) the derived allele frequency will be 3/160:","category":"page"},{"location":"data/#","page":"Processing data","title":"Processing data","text":"<!-- 162×1 Array{Char,1}:\n '4'\n 'G'\n 'G'\n 'G'\n 'C'\n 'C'\n 'C'\n 'C'\n ⋮  \n 'C'\n 'C'\n 'C'\n 'C'\n 'C'\n 'C'\n 'C'\n 'C' -->","category":"page"},{"location":"abc/#*ABC*-inference-from-empirical-data-1","page":"ABC inference","title":"ABC inference from empirical data","text":"","category":"section"},{"location":"abc/#Prior-distributions-from-analytical-estimations-1","page":"ABC inference","title":"Prior distributions from analytical estimations","text":"","category":"section"},{"location":"abc/#","page":"ABC inference","title":"ABC inference","text":"In this example we provide a solution to replicate results at Uricchio et al. 2019. We will simulate 37 cdot 10^6 summary statistics from random DFE to use as prior distribution in ABCreg. In this case we will need a set of empirical observed values in order to subset the summary statistics.","category":"page"},{"location":"abc/#","page":"ABC inference","title":"ABC inference","text":"We need to set the model accounting for the sampling value. The SFS is expected to be in raw frequencies. If the model is not properly set up, the SFS will not be correctly parsed. In our case, we are going to set up a model with default parameters only to parse the SFS and convolute the observed frequencies with a binomial distribution.","category":"page"},{"location":"abc/#","page":"ABC inference","title":"ABC inference","text":"using Analytical\nadap = Analytical.parameters(n=661)","category":"page"},{"location":"abc/#","page":"ABC inference","title":"ABC inference","text":"Once the model account for the number of samples we can open the files. The function Analytical.parseSfs will return polymorphic and divergent counts and SFS accounting for the whole spectrum: collect(1:adap.nn)/adap.nn. In addition an output file will be created contained the observed values to input in ABCreg.","category":"page"},{"location":"abc/#","page":"ABC inference","title":"ABC inference","text":"","category":"page"},{"location":"abc/#","page":"ABC inference","title":"ABC inference","text":"The module include a function to solve N times different genetic scenarios. We solve the analytical approximation taking into account random and independent values to draw DFE and alpha_(x). Each parameter combination are replicated to 5% frequency bins background selection values (saved at adap.bRange).","category":"page"},{"location":"abc/#","page":"ABC inference","title":"ABC inference","text":"# Execute one to compile the function","category":"page"},{"location":"abc/#","page":"ABC inference","title":"ABC inference","text":"To parallelize the process we created a thread pool inside summaryStats using the Distributed package. To parallel the process you only need to define the available process and add our model to each thread.","category":"page"},{"location":"abc/#","page":"ABC inference","title":"ABC inference","text":"# Load Distributed package and add threads\n\n# Load the pacakgein all the threads","category":"page"},{"location":"abc/#","page":"ABC inference","title":"ABC inference","text":"Alternatively, if you are going to use the command line script, please make the threads available when executing julia","category":"page"},{"location":"abc/#","page":"ABC inference","title":"ABC inference","text":"","category":"page"},{"location":"abc/#*ABC*-inference-1","page":"ABC inference","title":"ABC inference","text":"","category":"section"},{"location":"abc/#","page":"ABC inference","title":"ABC inference","text":"Generic ABC methods proceed by three main steps: (1) first sampling parameter values from prior distributions, (2) next simulating a model and calculating informative summary statistics, and lastly (3) comparing the simulated summary statistics to observed data. The parameter values that produce summary statistics that best match the observed data form an approximate posterior distribution. We link Julia with ABCreg. It will output one file per line in data. The files contain the posterior distributions. We return the posterior distributions, mean and quantiles.","category":"page"},{"location":"abc/#","page":"ABC inference","title":"ABC inference","text":"You can easily plot the posterior distributions using Julia or just input the files at your favorite plot software.","category":"page"},{"location":"abc/#","page":"ABC inference","title":"ABC inference","text":"(Image: NBViewer)","category":"page"},{"location":"mk/#","page":"MK approaches","title":"MK approaches","text":"#MK approaches We included other heuristic MK approaches in our module. All the function use the formated SFS and divergence data described at section ().","category":"page"},{"location":"mk/#Standard-MKT-1","page":"MK approaches","title":"Standard MKT","text":"","category":"section"},{"location":"mk/#","page":"MK approaches","title":"MK approaches","text":"The standard McDonald & Kreitman test (MKT) (McDonald and Kreitman, 1991) was developed to be applied to protein coding sequences, combining both divergence (D) and polymorphism (P) sites, and categorizing mutations as synonymous (P0, D0) and non-synonymous (Pi, Di). If all mutations are either strongly deleterious or neutral, then DiD0 is expected to roughly equal PiP0. In contrast, if positive selection is operating in the region, adaptive mutations rapidly reach fixation and thus contribute relative more to divergence than to polymorphism when compared to neutral mutations, and then DiD0  PiP0. Assuming that adaptive mutations contribute little to polymorphism but substantially to divergence, the proportion of non-synonymous substitutions than have been fixed by positive selection can be inferred as alpha = 1 - (fracP_iP_0cdotfracD_0D_i) ( Smith and Eyre-Walker 2002).","category":"page"},{"location":"mk/#Fay,-Waycoff-and-Wu-MKT-1","page":"MK approaches","title":"Fay, Waycoff and Wu MKT","text":"","category":"section"},{"location":"mk/#","page":"MK approaches","title":"MK approaches","text":"Proposed by Fay et al. (2002). This extensions remove all polymorphisms segregating at a frequency below a given threshold (usually 5%–15%). Although there is no consensus about what this threshold should be exactly, J. Charlesworth & Eyre-Walker  (2008) demonstrated that  estimates are robust using a frequency threshold of 15%, below which most slightly deleterious polymorphisms are found and removed. The estimates are reasonably accurate only when the rate of adaptive evolution is high, and the Distribution of Fitness Effects (DFE) of deleterious mutations is leptokurtic (J. Charlesworth & Eyre-Walker, 2008).","category":"page"},{"location":"mk/#imputed-MKT-(in-preparation)-1","page":"MK approaches","title":"imputed MKT (in preparation)","text":"","category":"section"},{"location":"mk/#Asymptotic-MKT-1","page":"MK approaches","title":"Asymptotic MKT","text":"","category":"section"},{"location":"mk/#","page":"MK approaches","title":"MK approaches","text":"Proposed by Messer and Petrov (2013). This extension is robust to the presence of selective sweeps (genetic hitchhiking) and to the segregation of slightly deleterious polymorphisms substitutions (BGS). In this approach, the authors defined alpha as a function that depends on the SFS of alleles. Therefore, is estimated in different frequency intervals (x), and these values are then adjusted to an exponential function. An exponential fit is suitable as the non-synonymous allele frequency is expected to decay exponentially over the respective levels of synonymous polymorphisms (Messer & Petrov, 2013).","category":"page"},{"location":"mk/#","page":"MK approaches","title":"MK approaches","text":"alpha_fit(x) = a+bcdote^-cx","category":"page"},{"location":"reference/#Model-parameters-1","page":"Reference","title":"Model parameters","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"adap is the only variable exported from Analytical module. It is a Mutable structure contaning the variables required to solve the analytical approach. Any value can be easly changed. Remember adap should be change before the execution, in other case, alpha_(x) will be solve with the default values. To change all the values at once, you can use Analytical.parameters in order to set specific models in a new variable.","category":"page"},{"location":"reference/#","page":"Reference","title":"Reference","text":"Analytical.parameters\nAnalytical.binomialDict\nAnalytical.Br\nAnalytical.setThetaF!\nAnalytical.setPpos!\nAnalytical.binomOp!","category":"page"},{"location":"reference/#Analytical.parameters","page":"Reference","title":"Analytical.parameters","text":"Mutable structure containing the variables required to solve the analytical approach. All the functions are solve using the internal values of the structure. For this reason, adap is the only exported variable. Adap should be change before the perform the analytical approach, in other case, $\\alpha_{(x)}$ will be solve with the default values.\n\nParameters\n\ngamNeg::Int64: Selection coefficient for deleterious alleles\ngL::Int64: Selection coefficient for weakly benefical alleles\ngH::Int64: Selection coefficient for strongly benefical alleles\nalLow::Float64: Proportion of α due to weak selection\nalTot::Float64: α\nthetaF::Float64: Mutation rate defining BGS strength\nthetaMidNeutral::Float64: Mutation rate on coding region\nal::Float64: DFE shape parameter \nbe::Float64: DFE scale parameter\nB::Float64: BGS strength\nbRange::Array{Float64,1}: BGS values to simulate\npposL::Float64: Fixation probabily of weakly beneficial alleles\npposH::Float64: Fixation probabily of strongly beneficial alleles\nN::Int64: Population size\nn::Int64: Sample size\nLf::Int64: Flanking region length\nrho::Float64: Recombination rate\nTE::Float64\n\n\n\n\n\n","category":"type"},{"location":"reference/#Analytical.binomialDict","page":"Reference","title":"Analytical.binomialDict","text":"Mutable structure containing the downsampled SFS. \n\nReturns\n\nbn::Dict: SparseMatrixCSC containing the binomial convolution\n\n\n\n\n\n","category":"type"},{"location":"reference/#Analytical.Br","page":"Reference","title":"Analytical.Br","text":"Br(Lmax,theta)\n\nExpected reduction in nucleotide diversity. Explored at Charlesworth B., 1994:\n\nfracpipi_0 = e^frac4muL2rL+t\n\nArguments\n\nparam::parameters\ntheta::Float64\n\nReturns\n\nFloat64: expected reduction in diversity given a non-coding length, mutation rate and defined recombination.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Analytical.setThetaF!","page":"Reference","title":"Analytical.setThetaF!","text":"setThetaF!(param)\n\nFind the optimum mutation given the expected reduction in nucleotide diversity (B value) in a locus.\n\nReturns\n\nadap.thetaF::Float64: changes adap.thetaF value.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Analytical.setPpos!","page":"Reference","title":"Analytical.setPpos!","text":"setPpos!(param)\n\nFind the probabilty of positive selected alleles given the model. It solves a equation system taking into account fixations probabilities of weakly and strong beneficial alleles.\n\nReturns\n\nTuple{Float64,Float64}: weakly and strong beneficial alleles probabilites.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Analytical.binomOp!","page":"Reference","title":"Analytical.binomOp!","text":"binomOp(param)\n\nBinomial convolution to sample the allele frequencies probabilites depeding on background selection values, and sample size.\n\nArguments\n\nparam::parameters\nconvolutedSamples::binomialDict\n\nReturns\n\nArray{Float64,2}: convoluted SFS given for each B value defined in the model. Results saved at param.bn.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Analytical-estimation-1","page":"Reference","title":"Analytical estimation","text":"","category":"section"},{"location":"reference/#Fixations-1","page":"Reference","title":"Fixations","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"Analytical.fixNeut\nAnalytical.fixNegB\nAnalytical.pFix\nAnalytical.fixPosSim","category":"page"},{"location":"reference/#Analytical.fixNeut","page":"Reference","title":"Analytical.fixNeut","text":"fixNeut()\n\nExpected neutral fixations rate reduce by B value.\n\nmathbbED_s = (1 - p_- - p_+) B frac12N\n\nReturns\n\nFloat64: expected rate of neutral fixations.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Analytical.fixNegB","page":"Reference","title":"Analytical.fixNegB","text":"fixNegB(ppos)\n\nExpected fixation rate from negative DFE.\n\nmathbbED_n- =  p_-left(2^-alphabeta^alphaleft(-zetaalphafrac2+beta2 + zetaalpha12(2-frac1N+beta)right)right)\n\nArguments\n\nppos::Float64: positive selected alleles probabilty.\n\nReturns\n\nFloat64: expected rate of fixations from negative DFE.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Analytical.pFix","page":"Reference","title":"Analytical.pFix","text":"pFix()\n\nExpected positive fixation rate.\n\nmathbbED_n+ =  p_+ cdot B cdot (1 - e^(-2s))\n\nArguments\n\nppos::Float64: positive selected alleles probabilty.\n\nReturns\n\nFloat64: expected rate of positive fixation.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Analytical.fixPosSim","page":"Reference","title":"Analytical.fixPosSim","text":"fixPosSim(gamma,ppos)\n\nExpected positive fixations rate reduced due to the impact of background selection and linkage. The probabilty of fixation of positively selected alleles is reduced by a factor Φ across all deleterious linked sites Analytical.phiReduction.\n\nmathbbED_n+ =  Phi cdot mathbbED_n+\n\nArguments\n\nppos::Float64: positive selected alleles probabilty.\n\nReturns\n\nFloat64: expected rate of positive fixations under background selection\n\n\n\n\n\n","category":"function"},{"location":"reference/#Polymorphism-1","page":"Reference","title":"Polymorphism","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"Analytical.DiscSFSNeutDown\nAnalytical.DiscSFSSelPosDown\nAnalytical.DiscSFSSelNegDown\nAnalytical.cumulativeSfs","category":"page"},{"location":"reference/#Analytical.DiscSFSNeutDown","page":"Reference","title":"Analytical.DiscSFSNeutDown","text":"DiscSFSNeutDown()\n\nExpected rate of neutral allele frequency reduce by backgrou\tnd selection. The spectrum depends on the number of individual []\n\nmathbbEPs_(x) = sumx^*=xx^*=1f_B(x)\n\nReturn:\n\nArray{Float64}: expected rate of neutral alleles frequencies.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Analytical.DiscSFSSelPosDown","page":"Reference","title":"Analytical.DiscSFSSelPosDown","text":"DiscSFSSelPosDown(gammaValue,ppos)\n\nExpected rate of positive selected allele frequency reduce by background selection. The spectrum depends on the number of individuals.\n\nArguments\n\ngammaValue::Int64: selection strength.\nppos::Float64: positive selected alleles probabilty.\n\nReturn:\n\nArray{Float64}: expected positive selected alleles frequencies.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Analytical.DiscSFSSelNegDown","page":"Reference","title":"Analytical.DiscSFSSelNegDown","text":"DiscSFSSelNegDown(param,ppos)\n\nExpected rate of positive selected allele frequency reduce by background selection. Spectrum drawn on a gamma DFE. It depends on the number of individuals.\n\nArguments\n\nppos::Float64: positive selected alleles probabilty.\n\nReturn:\n\nArray{Float64}: expected negative selected alleles frequencies.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Analytical.cumulativeSfs","page":"Reference","title":"Analytical.cumulativeSfs","text":"cumulativeSfs(sfsTemp)\n\nChanging SFS considering all values above a frequency x. The original asymptotic-MK approach takes Pn(x) and Ps(x) as the number of polymorphic sites at frequency x rather than above x, but this approach scales poorly as sample size increases. We define the polymorphic spectrum as stated above since these quantities trivially have the same asymptote but are less affected by changing sample size.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Summary-statistics-1","page":"Reference","title":"Summary statistics","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"Analytical.analyticalAlpha\nAnalytical.poissonFixation\nAnalytical.poissonPolymorphism\nAnalytical.sampledAlpha\nAnalytical.alphaByFrequencies\nAnalytical.bgsIter\nAnalytical.summaryStats\nAnalytical.gettingRates\nAnalytical.summaryStatsFromRates\nAnalytical.ratesToSummaries","category":"page"},{"location":"reference/#Analytical.analyticalAlpha","page":"Reference","title":"Analytical.analyticalAlpha","text":"analyticalAlpha(param, convolutedSamples)\n\nAnalytical α(x) estimation. Solve α(x) generally. We used the expected rates of divergence and polymorphism to approach the asympotic value accouting for background selection, weakly and strong positive selection. α(x) can be estimated taking into account the role of positive selected alleles or not. In this way we explore the role of linkage to deleterious alleles in the coding region.\n\nmathbbEalpha_x =  1 - left(fracmathbbED_smathbbED_NfracmathbbEP_NmathbbEP_Sright)\n\nArguments\n\nparam::parameters\nconvolutedSamples::binomialDict\n\nReturns\n\nArray{Float64,1} α(x).\n\n\n\n\n\n","category":"function"},{"location":"reference/#Analytical.poissonFixation","page":"Reference","title":"Analytical.poissonFixation","text":"poissonFixation(observedValues,λds, λdn)\n\nDivergence sampling from Poisson distribution. The expected neutral and selected fixations are subset through their relative expected rates (fixNeut, fixNegB, fixPosSim). Empirical values are used are used to simulate the locus L along a branch of time T from which the expected Ds and Dn raw count estimated given the mutation rate (mu). Random number generation is used to subset samples arbitrarily given the success rate lambda in the distribution.\n\nmathbbED_N = X in Poissonleft(lambda = D times leftfracmathbbED_+ + mathbbED_-mathbbED_+ + mathbbED_- + mathbbED_0rightright)\n\nmathbbED_S = X in Poissonleft(lambda = D times leftfracmathbbED_0mathbbED_+ + mathbbED_- + mathbbED_0rightright)\n\nArguments\n\nobservedValues::Array: Array containing the total observed divergence.\nλds::Float64: expected neutral fixations rate.\nλdn::Float64: expected selected fixations rate.\n\nReturns\n\nArray{Int64,1} containing the expected count of neutral and selected fixations.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Analytical.poissonPolymorphism","page":"Reference","title":"Analytical.poissonPolymorphism","text":"poissonPolymorphism(observedValues,λps,λpn)\n\nPolymorphism sampling from Poisson distributions. The total expected neutral and selected polimorphism are subset through the relative expected rates at the frequency spectrum (fixNeut, DiscSFSNeutDown,). Empirical sfs are used to simulate the locus L along a branch of time T from which the expected Ps and Pn raw count are estimated given the mutation rate (mu). Random number generation is used to subset samples arbitrarily from the whole sfs given each frequency success rate lambda in the distribution.\n\nThe success rate managing the Poisson distribution by the observed count each frequency.  We considered both sampling variance and process variance is affecting the number of variable alleles we sample from SFS. This variance arises from the random mutation-fixation process along the branch. To incorporate this variance we do one sample per frequency-bin and use the total sampled variation and the SFS for the summary statistics.\n\nmathbbEP_N = sum_x=0^x=1 X in Poissonleft(lambda = SFS_(x) times leftfracmathbbEP_+(x) + mathbbEP_-(x)mathbbEP_+(x) + mathbbEP_-(x) + mathbbEP_0(x)rightright)\n\nmathbbEP_S = sum_x=0^x=1 X in Poissonleft(lambda = SFS_(x) times leftfracmathbbEP_0(x)mathbbEP_+(x) + mathbbEP_-(x) + mathbbEP_0(x)rightright)\n\nArguments\n\nobservedValues::Array{Int64,1}: Array containing the total observed divergence.\nλps::Array{Float64,1}: expected neutral site frequency spectrum rate.\nλpn::Array{Float64,1}: expected selected site frequency spectrum rate.\n\nReturns\n\nArray{Int64,2} containing the expected total count of neutral and selected polymorphism.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Analytical.sampledAlpha","page":"Reference","title":"Analytical.sampledAlpha","text":"sampledAlpha(observedValues,λds, λdn)\n\nOuput the expected values from the Poisson sampling process. Please check poissonFixation and poissonPolymorphism to understand the samplingn process. α(x) is estimated through the expected values of Dn, Ds, Pn and Ps.\n\nArguments\n\nparam::parameters: Array containing the total observed divergence.\nd::Array: observed divergence.\nafs::Array: observed polymorphism.\nλdiv::Array{Float64,2}: expected fixations rate.\nλdiv::Array{Float64,2}: expected site frequency spectrum rates.\n\nReturns\n\nαS,expDn,expDs,expPn,expPs,ssAlpha\n\nArray{Int64,2} containing α(x) values.\nArray{Int64,1} expected non-synonymous divergence.\nArray{Int64,1} expected synonymous divergence.\nArray{Int64,1} expected non-synonymous polymorphism.\nArray{Int64,1} expected synonymous polymorphism.\nArray{Int64,1} expected synonymous polymorphism.\nArray{Int64,1} expected synonymous polymorphism.\nArray{Int64,2} containing α(x) binned values.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Analytical.gettingRates","page":"Reference","title":"Analytical.gettingRates","text":"gettingRates(gammaL,gammaH,pposL,pposH,observedData,nopos)\n\nEstimating analytical rates of fixation and polymorphism to approach α value accouting for background selection, weakly and strong positive selection. Output values will be used to sample from a Poisson distribution the total counts of polymorphism and divergence using observed data. \n\nArguments\n\nparam::parameters\ncnvBinom::SparseMatrixCSC{Float64,Int64}\n\nReturns\n\nArray{Float64,2} containing solved model, fixation and polymorphic rates\n\n\n\n\n\n","category":"function"},{"location":"reference/#Analytical.summaryStatsFromRates","page":"Reference","title":"Analytical.summaryStatsFromRates","text":"param::parameters,rates::JLD2.JLDFile,analysisFolder::String,summstatSize::Int64,replicas::Int64,bootstrap::Bool)\n\nEstimate summary statistics using observed data and analytical rates. analysisFolder will check for the SFS and divergence file and will be used to output summary statistics.\n\nArguments\n\nparam::parameters\nrates::JLD2.JLDFile\nanalysisFolder::String\nsummstatSize::Int64\nreplicas::Int64\nbootstrap::Bool\n\nOutput\n\nObserded data and summary statistics to ABC inference\n\n\n\n\n\n","category":"function"},{"location":"reference/#Inference-tools-1","page":"Reference","title":"Inference tools","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"Analytical.parseSfs\nAnalytical.ABCreg\nAnalytical.meanQ","category":"page"},{"location":"reference/#Analytical.parseSfs","page":"Reference","title":"Analytical.parseSfs","text":"parseSfs(;data,output,sfsColumns,divColumns)\n\nFunction to parse polymorphism and divergence by subset of genes. The input data is based on supplementary material described at Uricchio et al. 2019. Please be sure the file is tabulated.\n\nGeneId Pn DAF seppareted by commas Ps DAF separated by commas Dn Ds\nXXXX 0 ,0,0,0,0,0,0,0,0 0 ,0,0,0,0,0,0,0,0 0 0\nXXXX 0 ,0,0,0,0,0,0,0,0 0 ,0,0,0,0,0,0,0,0 0 0\nXXXX 0 ,0,0,0,0,0,0,0,0 0 ,0,0,0,0,0,0,0,0 0 0\n\nArguments\n\ndata: String or Array of strings containing files names with full path.\noutput::String: path to save file. Containing one file per input file.\nsfsColumns::Array{Int64,1}: non-synonymous and synonymous daf columns. Please introduce first the non-synonymous number.\ndivColumns::Array{Int64,1}: non-synonymous and synonymous divergence columns. Please introduce first the non-synonymous number.\n\nReturns\n\nArray{Float64,1}: α values\nArray{Float64,2}: Site Frequency Spectrum\nArray{Float64,1}: Synonymous and non-synonymous divergence counts\n\n\n\n\n\n\n","category":"function"},{"location":"reference/#Analytical.ABCreg","page":"Reference","title":"Analytical.ABCreg","text":"ABCreg(analysis, replicas, P, S, tol, workers, abcreg, parallel)\n\nCould be parallelize if GNU parallel is available in your system\n\n\n\n\n\n","category":"function"},{"location":"reference/#Raw-data-tools-1","page":"Reference","title":"Raw data tools","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"Analytical.uSfsFromFasta","category":"page"},{"location":"#ABC-MK-1","page":"Home","title":"ABC-MK","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"ABC-MK is an analytical approximation to alpha_(x). We have explored the impact of linkage and background selection at positive selected alleles sites. The package solves analytical approximations for different genetic scenarios in order to estimate the strength and rate of adaptation.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Our approach estimates directly alpha_(x) and several statistics (B, alpha_W, alpha_S) associated to random DFE. In conjunction, the associated values to these DFE can be used as summary statistics at ABC methods. Therefore, our method can estimate rate and strength of adaption in models and non-models organisms, for which previous DFE and demography are unknown.","category":"page"},{"location":"#Installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#Docker-1","page":"Home","title":"Docker","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"We highly recommend to use the Docker image to execute the software. The Docker image is based on Debian and include all the software needed to run the pipeline. You can access to Debian system or Jupyter pulling the image from dockerhub. Remember to link the folder /analysis with any folder at your ${HOME} directory to save the results:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"# Pull the image\ndocker pull jmurga/abcmk\n# Run docker linking some local volume to export data\ndocker run -i -t -v ${HOME}/<folderPath>:/analysis/folder jmurga/mktest\n# Run jupyter notebook from docker image. Change the port if 8888 is already used\ndocker run -i -t -v ${HOME}/<folderPath>:/analysis/folder -p 8888:8888 jmurga/mktest /bin/bash -c \"jupyter-lab --ip='*' --port=8888 --no-browser --allow-root\"","category":"page"},{"location":"#Singularity-1","page":"Home","title":"Singularity","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"We have created a Singularity container to use the software into HPC systems","category":"page"},{"location":"#","page":"Home","title":"Home","text":"singularity pull library://jmurga/default/abcmk","category":"page"},{"location":"#Scratch-installation-1","page":"Home","title":"Scratch installation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"To install our module from scratch we highly recommend to use LTS official Julia binaries","category":"page"},{"location":"#","page":"Home","title":"Home","text":"JULIA_VERSION=1.6.1\ncurl -o ${HOME}/julia-${JULIA_VERSION}-linux-x86_64.tar.gz https://julialang-s3.julialang.org/bin/linux/x64/1.6/julia-${JULIA_VERSION}-linux-x86_64.tar.gz\ntar -zxf ${HOME}/julia-${JULIA_VERSION}-linux-x86_64.tar.gz -C ${HOME}","category":"page"},{"location":"#","page":"Home","title":"Home","text":"If is your first time using Julia please remember to export Julia binaries to your path. In this way you will execute Julia using the command julia","category":"page"},{"location":"#","page":"Home","title":"Home","text":"echo 'export PATH=\"${HOME}/julia-${JULIA_VERSION}/bin:$PATH\"' >> ${HOME}/.bashrc\nsource ${HOME}/.bashrc","category":"page"},{"location":"#","page":"Home","title":"Home","text":"You can easly install the Julia package executing","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia -e 'using Pkg;Pkg.add(PackageSpec(path=\"https://github.com/jmurga/Analytical.jl\"))'","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Or from Pkg REPL (by pressing ] at Julia interpreter):","category":"page"},{"location":"#","page":"Home","title":"Home","text":"add https://github.com/jmurga/Analytical.jl","category":"page"},{"location":"#ABC-1","page":"Home","title":"ABC","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"We link ABCreg with Julia in order to perform ABC inference, although another ABC software could be used (abc (R package), ABCToolBox, etc). If you are going to use ABCreg to directly make inference from our software please cite the publication and compile it in your system. Anyway, once you get the summary statistic files you can use any other ABC software.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"ABCreg needs GSL and libz to work. Please install both libraries before compile the software:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"# Installing make and git just in case they are not available in your system\nsudo apt install libgsl-dev libz-dev build-essential git","category":"page"},{"location":"#","page":"Home","title":"Home","text":"git clone https://github.com/molpopgen/ABCreg.git ${HOME}/ABCreg\ncd ${HOME}/ABCreg/src && make","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Once ABCreg is installed you can add the binary to your PATH:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"echo 'export PATH=\"${HOME}/ABCreg/src/:$PATH\"' >> ${HOME}/.bashrc\nsource ${HOME}/.bashrc","category":"page"},{"location":"#R-1","page":"Home","title":"R","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"We used R to estimate the Maximum-A-Posteriori (MAP) from posterior distributions following ABCreg examples. We linked Julia and R internally. The module contains functions to perform the estimations without quit the Julia session.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Please if you are going to perform MAP estimates and plot using our module, be sure you have installed R and the following packages: ggplot2, data.table, locfit. ","category":"page"},{"location":"#","page":"Home","title":"Home","text":"R -e \"install.packages(c('ggplot2','data.table','locfit'))\"","category":"page"},{"location":"#Dependencies-1","page":"Home","title":"Dependencies","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"All Julia dependencies are installed within the package. You don't need to install them manually.","category":"page"},{"location":"#Mandatory-dependencies-to-solve-the-analytical-equations-1","page":"Home","title":"Mandatory dependencies to solve the analytical equations","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Roots - root finding.\nNLsolve - non-linear systems of equations solver.\nDistributions - probability distributions.\nSpecialFunctions - special mathematical functions in Julia.\nQuadmath - multiprecision numerical computing.\nPoissonRandom - Poisson random number generator.\nParameters - custom keyword constructor.","category":"page"},{"location":"#The-following-dependencies-are-required-to-use-all-the-funcionalities-(parse-SFS,-plots,-parse-multi-Fasta,-etc.)-1","page":"Home","title":"The following dependencies are required to use all the funcionalities (parse SFS, plots, parse multi-Fasta, etc.)","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"CSV\nParsers\nStatsBase\nDataFrames\nGZip\nOrderedCollections\nPlots\nFastaIO","category":"page"},{"location":"#References-1","page":"Home","title":"References","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Uricchio, L.H., Petrov, D.A. & Enard, D. Exploiting selection at linked sites to infer the rate and strength of adaptation. Nat Ecol Evol 3, 977–984 (2019). https://doi.org/10.1038/s41559-019-0890-6\nPhilipp W. Messer, Dmitri A. Petrov. Frequent adaptation and the McDonald–Kreitman test. Proceedings of the National Academy of Sciences May 2013, 110 (21) 8615-8620. https://doi.org/10.1073/pnas.1220835110\nNordborg, M., Charlesworth, B., & Charlesworth, D. (1996). The effect of recombination on background selection. Genetical Research, 67(2), 159-174. https://doi.org/10.1017/S0016672300033619\nR R Hudson and N L Kaplan. Deleterious background selection with recombination. Genetics December 1, 1995 vol. 141 no. 4 1605-1617.\nLinkage and the limits to natural selection. N H Barton. Genetics June 1, 1995 vol. 140 no. 2 821-841\nThornton, K.R. Automating approximate Bayesian computation by local linear regression. BMC Genet 10, 35 (2009). https://doi.org/10.1186/1471-2156-10-35","category":"page"}]
}
