var documenterSearchIndex = {"docs":
[{"location":"reference/#Model-parameters-1","page":"Reference","title":"Model parameters","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"adap is the only variable exported from Analytical module. It is a Mutable structure contaning the variables required to solve the analytical approach. Any value can be easly changed. Remember adap should be change before the execution, in other case, alpha_(x) will be solve with the default values. To change all the values at once, you can use Analytical.changeParameters in order to set specific models.","category":"page"},{"location":"reference/#","page":"Reference","title":"Reference","text":"Analytical.adap","category":"page"},{"location":"reference/#Analytical.adap","page":"Reference","title":"Analytical.adap","text":"adap( \n\tgam_neg::Int64,\n\tgL::Int64,\t\n\tgH::Int64,\n\talLow::Float64,\n\talTot::Float64,\n\ttheta_f::Float64,\n\ttheta_mid_neutral::Float64,\n\tal::Float64,\n\tbe::Float64,\n\tB::Float64,\n\tbRange::Array{Float64,1}\n\tpposL::Float64,\n\tpposH::Float64,\n\tN::Int64,\n\tn::Int64,\n\tLf::Int64,\n\trho::Float64,\n\tTE::Float64,\n)\n\nMutable structure containing the variables required to solve the analytical approach. All the functions are solve using the internal values of the structure. For this reason, adap is the only exported variable. Adap should be change before the perform the analytical approach, in other case, $\\alpha_{(x)}$ will be solve with the default values.\n\nParameters\n\ngam_neg::Int64: \ngL::Int64: \ngH::Int64: \nalLow::Float64: \nalTot::Float64: \ntheta_f::Float64: \ntheta_mid_neutral::Float64: \nal::Float64: \nbe::Float64: \nB::Float64: \nbRange::Array{Float64,1}:\npposL::Float64: \npposH::Float64: \nN::Int64: \nn::Int64: \nLf::Int64: \nrho::Float64: \nTE::Float64: \n\n\n\n\n\n","category":"constant"},{"location":"reference/#","page":"Reference","title":"Reference","text":"Analytical.changeParameters\nAnalytical.Br\nAnalytical.set_theta_f\nAnalytical.setPpos\nAnalytical.binomOp","category":"page"},{"location":"reference/#Analytical.changeParameters","page":"Reference","title":"Analytical.changeParameters","text":"changeParameters()\n\nFunction to re-assign values to mutable struct adap. When values is not defined, it will be reset to the default value.\n\nParameters\n\ngam_neg::Int64: \ngL::Int64: \ngH::Int64: \nalLow::Float64: \nalTot::Float64: \ntheta_f::Float64: \ntheta_mid_neutral::Float64: \nal::Float64: \nbe::Float64: \nB::Float64: \nbRange::Array{Float64,1}:\npposL::Float64: \npposH::Float64: \nN::Int64: \nn::Int64: \nLf::Int64: \nrho::Float64: \nTE::Float64: \n\n\n\n\n\n","category":"function"},{"location":"reference/#Analytical.Br","page":"Reference","title":"Analytical.Br","text":"Br(Lmax,theta)\n\nExpected reduction in nucleotide diversity. Explored at Charlesworth B., 1994:\n\nfracpipi_0 = e^frac4muL2rL+t\n\nArguments\n\nLmax::Int64: non-coding flaking length\ntheta::Float64\n\nReturns\n\nFloat64: expected reduction in diversity given a non-coding length, mutation rate and defined recombination.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Analytical.set_theta_f","page":"Reference","title":"Analytical.set_theta_f","text":"set_theta_f()\n\nFind the optimum mutation given the expected reduction in nucleotide diversity (B value ) in a locus.\n\nReturns\n\nadap.theta_f::Float64: changes adap.theta_f value.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Analytical.setPpos","page":"Reference","title":"Analytical.setPpos","text":"setPpos()\n\nFind the probabilty of positive selected alleles given the model. It solves a equation system taking into account fixations probabilities of weakly and strong beneficial alleles.\n\nReturns\n\nTuple{Float64,Float64}: weakly and strong beneficial alleles probabilites.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Analytical.binomOp","page":"Reference","title":"Analytical.binomOp","text":"binomOp(B)\n\nSite Frequency Spectrum convolution depeding on background selection values. Pass the SFS to a binomial distribution to sample the allele frequencies probabilites.\n\nReturns\n\nArray{Float64,2}: convoluted SFS given a B value. It will be saved at adap.bn.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Analytical-estimation-1","page":"Reference","title":"Analytical estimation","text":"","category":"section"},{"location":"reference/#Fixations-1","page":"Reference","title":"Fixations","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"Analytical.fixNeut\nAnalytical.fixNegB\nAnalytical.pFix\nAnalytical.fixPosSim","category":"page"},{"location":"reference/#Analytical.fixNeut","page":"Reference","title":"Analytical.fixNeut","text":"fixNeut()\n\nExpected neutral fixations rate reduce by a background selection value.\n\nmathbbED_s = (1 - p_- - p_+) B frac12N\n\nReturns\n\nFloat64: expected rate of neutral fixations.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Analytical.fixNegB","page":"Reference","title":"Analytical.fixNegB","text":"fixNegB(ppos)\n\nExpected fixation rate from negative DFE.\n\nmathbbED_n- =  p_-left(2^-alphabeta^alphaleft(-zetaalphafrac2+beta2 + zetaalpha12(2-frac1N+beta)right)right)\n\nArguments\n\nppos::Float64: selection coefficient.\n\nReturns\n\nFloat64: expected rate of fixations from negative DFE.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Analytical.pFix","page":"Reference","title":"Analytical.pFix","text":"pFix()\n\nExpected positive fixation rate.\n\nmathbbED_n+ =  p_+ cdot B cdot (1 - e^(-2s))\n\nArguments\n\nppos::Float64: selection coefficient.\n\nReturns\n\nFloat64: expected rate of positive fixation.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Analytical.fixPosSim","page":"Reference","title":"Analytical.fixPosSim","text":"fixPosSim(gamma,ppos)\n\nExpected positive fixations rate reduced due to the impact of background selection and linkage. The probabilty of fixation of positively selected alleles is reduced by a factor Φ across all deleterious linked sites Analytical.phiReduction.\n\nmathbbED_n+ =  Phi cdot mathbbED_n+\n\nArguments\n\nppos::Float64: selection coefficient\n\nReturns\n\nFloat64: expected rate of positive fixations under background selection\n\n\n\n\n\n","category":"function"},{"location":"reference/#Polymorphism-1","page":"Reference","title":"Polymorphism","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"Analytical.DiscSFSNeutDown\nAnalytical.DiscSFSPosDown\nAnalytical.DiscSFSNegDown\nAnalytical.cumulativeSfs","category":"page"},{"location":"reference/#Analytical.DiscSFSNeutDown","page":"Reference","title":"Analytical.DiscSFSNeutDown","text":"DiscSFSNeutDown()\n\nExpected rate of neutral allele frequency reduce by background selection. The spectrum depends on the number of individual []\n\nmathbbEPs_(x) = sumx^*=xx^*=1f_B(x)\n\nReturn:\n\nArray{Float64}: expected rate of neutral alleles frequencies.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Analytical.cumulativeSfs","page":"Reference","title":"Analytical.cumulativeSfs","text":"cumulativeSfs(sfsTemp)\n\nChanging SFS considering all values above a frequency x. The original asymptotic-MK approach takes Pn(x) and Ps(x) as the number of polymorphic sites at frequency x rather than above x, but this approach scales poorly as sample size increases. We define the polymorphic spectrum as stated above since these quantities trivially have the same asymptote but are less affected by changing sample size.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Summary-statistics-1","page":"Reference","title":"Summary statistics","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"Analytical.poissonFixation\nAnalytical.poissonPolymorphism\nAnalytical.alphaByFrequencies","category":"page"},{"location":"reference/#Analytical.poissonFixation","page":"Reference","title":"Analytical.poissonFixation","text":"poissonFixation(observedValues,λds, λdn)\n\nDivergence sampling from Poisson distribution. The expected neutral and selected fixations are subset through their relative expected rates (Analytical.fixNeut, Analytical.fixNegB, Analytical.fixPosSim). Empirical values are used are used to simulate the locus L along a branch of time T from which the expected Ds and Dn raw count estimated given the mutation rate (mu). Random number generation is used to subset samples arbitrarily given the success rate lambda in the distribution.\n\nArguments\n\nobservedValues::Array{Int64,1}: Array containing the total observed divergence.\nλds: expected neutral fixations rate.\nλdn: expected selected fixations rate.\n\nReturns\n\nArray{Int64,1} containing the expected count of neutral and selected fixations.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Analytical.poissonPolymorphism","page":"Reference","title":"Analytical.poissonPolymorphism","text":"poissonPolymorphism(observedValues,λps,λpn)\n\nPolymorphism sampling from Poisson distributions. The total expected neutral and selected polimorphism are subset through the relative expected rates at the frequency spectrum (Analytical.fixNeut, Analytical.DiscSFSNeutDown,). Empirical sfs are used to simulate the locus L along a branch of time T from which the expected Ps and Pn raw count are estimated given the mutation rate (mu). Random number generation is used to subset samples arbitrarily from the whole sfs given each frequency success rate lambda in the distribution.\n\nArguments\n\nobservedValues::Array{Int64,1}: Array containing the total observed divergence.\nλps: expected neutral site frequency spectrum rate.\nλpn: expected selected site frequency spectrum rate.\n\nReturns\n\nArray{Int64,1} containing the expected total count of neutral and selected polymorphism.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Analytical.alphaByFrequencies","page":"Reference","title":"Analytical.alphaByFrequencies","text":"alphaByFrequencies(gammaL,gammaH,pposL,pposH,observedData,nopos)\n\nAnalytical α(x) estimation. We used the expected rates of divergence and polymorphism to approach the asympotic value accouting for background selection, weakly and strong positive selection. α(x) can be estimated taking into account the role of positive selected alleles or not. We solve α(x) from empirical observed values. The values will be use to sample from a Poisson distribution the total counts of polymorphism and divergence using the rates. The mutation rate, the locus length and the time of the branch should be proportional to the observed values. \n\nmathbbEalpha_x =  1 - left(fracmathbbED_smathbbED_NfracmathbbEP_NmathbbEP_Sright)\n\nArguments\n\ngammaL::Int64: strength of weakly positive selection\ngammaH::Int64: strength of strong positive selection\npposL::Float64: probability of weakly selected allele\npposH::Float64: probability of strong selected allele\nobservedData::Array{Any,1}: Array containing the total observed divergence, polymorphism and site frequency spectrum.\nnopos::String(\"pos\",\"nopos\",\"both\"): string to perform α(x) account or not for both positive selective alleles.\n\nReturns\n\nTuple{Array{Float64,1},Array{Float64,2}} containing α(x) and the summary statistics array (Ds,Dn,Ps,Pn,α).\n\n\n\n\n\n","category":"function"},{"location":"reference/#Inference-tools-1","page":"Reference","title":"Inference tools","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"Analytical.parseSfs\nAnalytical.ABCreg\nAnalytical.meanQ","category":"page"},{"location":"reference/#Analytical.parseSfs","page":"Reference","title":"Analytical.parseSfs","text":"parseSfs(;data,output,sfsColumns,divColumns)\n\nFunction to parse polymorphism and divergence by subset of genes. The input data is based on supplementary material described at Uricchio et al. 2019.\n\nGeneId Pn DAF seppareted by commas Ps DAF separated by commas Dn Ds\nXXXX 0 ,0,0,0,0,0,0,0,0 0 ,0,0,0,0,0,0,0,0 0 0\nXXXX 0 ,0,0,0,0,0,0,0,0 0 ,0,0,0,0,0,0,0,0 0 0\nXXXX 0 ,0,0,0,0,0,0,0,0 0 ,0,0,0,0,0,0,0,0 0 0\n\nArguments\n\ndata: String or Array of strings containing files names with full path.\noutput::String: path to save file. Containing one file per input file.\nsfsColumns::Array{Int64,1}: non-synonymous and synonymous daf columns. Please introduce first the non-synonymous number.\ndivColumns::Array{Int64,1}: non-synonymous and synonymous divergence columns. Please introduce first the non-synonymous number.\n\nReturns\n\nArray{Array{Int64,N} where N,1}: Array of arrays containing the total polymorphic sites (1), total Site Frequency Spectrum (2) and total divergence (3). Each array contains one row/column per file.\nFile writed in output\n\n\n\n\n\n","category":"function"},{"location":"reference/#Analytical.ABCreg","page":"Reference","title":"Analytical.ABCreg","text":"ABCreg(data, prior, nparams, nsummaries, outputPath, outputPrefix,tolerance, regressionMode,regPath)\n\nJulia link to execute ABCreg. You should take into account that any other ABC could be used once the prior distributions are done. If you consider to use ABCreg please cite the publication and compile it in your system.\n\nArguments\n\ndata::String: Observed data. Produced by parseSfs.\noutput::String: path to save file. ABCreg will produce one file per lines inside data.\nnparams::Int64: number of parameters in prior distributions.\nnsummaries::Int64: number of observed summary statistics.\noutputPath::String: output path.\noutputPrefix::String: output prefix name.\ntolerance::Float64: tolerance for rejection acceptance in Euclidian distance.\nregressionMode::String: transformation (T or L).\n\nReturns\n\nArray{Array{Int64,N} where N,1}: Array of arrays containing the total polymorphic sites (1), total Site Frequency Spectrum (2) and total divergence (3). Each array contains one row/column per file.\nFile writed in output\n\n\n\n\n\n\n","category":"function"},{"location":"reference/#Analytical.meanQ","page":"Reference","title":"Analytical.meanQ","text":"meanQ(x,columns)\n\nFunction to retrieve mean and quantiles (95%) from posterior distributions.\n\nArguments\n\nx::Array{Float64,2}: posterior distribution.\ncolumns::Array{Int64,1}: columns to process.\n\nReturns\n\nArray{Array{Float64,2},1}: Array of array containing mean and quantiles by posterior distribution. Each array contains $\\alpha_{S}$, $\\alpha_{W}$ and $\\alpha$ information by column.\n\n\n\n\n\n","category":"function"},{"location":"#ABC-MK-1","page":"Home","title":"ABC-MK","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"ABC-MK is an analytical approximation to alpha_x. We explore the impact of linkage and background selection at positive selected alleles sites. The package solves anylitical approximations for different genetic scenarios in order to estimate the strenght and rate of adaptation. ","category":"page"},{"location":"#","page":"Home","title":"Home","text":"When empircal values of polymorphim and divergence are given, they will be used to discern their expected correspoding values modeled under any Distribution of Fitness Effect (DFE) and background selection values (B). ","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Our goal is to subset summary statistics given empirical observed values that would be used as prior distributions in ABC algorithms. Please check","category":"page"},{"location":"#Installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"To install our module we highly recommend to use LTS official Julia binaries. If is your first time using Julia, you can easily export the Julia bin through export PATH=\"/path/to/directory/julia-1.v.v/bin:$PATH\" in your shell. Since we use scipy to solve equations, the package depends on PyCall.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia -e 'using Pkg;Pkg.add(PackageSpec(path=\"https://github.com/jmurga/Analytical.jl\"))'","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Or from Pkg REPL (by pressing ] at Julia interpreter):","category":"page"},{"location":"#","page":"Home","title":"Home","text":"add https://github.com/jmurga/Analytical.jl","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Scipy installation  ","category":"page"},{"location":"#","page":"Home","title":"Home","text":"You can install scipy on your default Python or install it through Julia Conda:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia -e 'using Pkg;Pkg.add(\"PyCall\");using PyCall;pyimport_conda(\"scipy.optimize\", \"scipy\")'","category":"page"},{"location":"#","page":"Home","title":"Home","text":"If you cannot install properly scipy through Julia Conda try the following:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Set an empty Python enviroment and re-build PyCall: ENV[\"PYTHON\"]=\"\";  Pkg.build(\"PyCall\")\nRe-launch Julia and install the scipy.optimize module: using PyCall;pyimport_conda(\"scipy.optimize\", \"scipy)","category":"page"},{"location":"#Docker-1","page":"Home","title":"Docker","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"We provide a Docker image based on Debian including Julia and Jupyter notebook. You can access to Debian system or just to Jupyter pulling the image from dockerhub. Remember to link the folder /analysis with any folder at your home to save the results:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"# Pull the image\ndocker pull jmurga/mktest\n# Run docker bash interactive session linking to some local volume to export data. \ndocker run -i -t -v ${HOME}/folderPath:/analysis/folder  jmurga/mktest\n# Run only jupyter notebook from docker image. Change the port if 8888 is already used\ndocker run -i -t -v ${HOME}/folderPath:/analysis/folder -p 8888:8888 jmurga/mktest /bin/bash -c \"jupyter-lab --ip='*' --port=8888 --no-browser --allow-root\"","category":"page"},{"location":"#Dependencies-1","page":"Home","title":"Dependencies","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"All the dependecies are installed within the package. You don't need to install manually. If you experiment any problem contact us or try to reinstall Pycall and scipy.","category":"page"},{"location":"#Mandatory-dependencies-to-solve-the-analytical-equations-1","page":"Home","title":"Mandatory dependencies to solve the analytical equations","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Roots - root finding.\nDistributions - probability distributions.\nPyCall - directly call and fully interoperate with Python.\nSpecialFunctions - special mathematical functions in Julia.\nParameters - custom keyword constructor.","category":"page"},{"location":"#The-following-dependencies-are-required-to-use-all-the-funcionalities-(parse-SFS,-plots,-etc.)-1","page":"Home","title":"The following dependencies are required to use all the funcionalities (parse SFS, plots, etc.)","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"CSV\nParsers\nStatsBase\nDataFrames\nGZip","category":"page"},{"location":"#ABC-1","page":"Home","title":"ABC","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"We link ABCreg with julia in order to perform ABC estimations. If you are going to use ABCreg to do inference please cite the publication and compile it in your system. Anyway, once you get the priors distributions you can use any other ABC software.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"git clone https://github.com/molpopgen/ABCreg.git\ncd ABCreg/src && make","category":"page"},{"location":"#References-1","page":"Home","title":"References","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Uricchio, L.H., Petrov, D.A. & Enard, D. Exploiting selection at linked sites to infer the rate and strength of adaptation. Nat Ecol Evol 3, 977–984 (2019). https://doi.org/10.1038/s41559-019-0890-6\nPhilipp W. Messer, Dmitri A. Petrov. Frequent adaptation and the McDonald–Kreitman test. Proceedings of the National Academy of Sciences May 2013, 110 (21) 8615-8620. https://doi.org/10.1073/pnas.1220835110\nNordborg, M., Charlesworth, B., & Charlesworth, D. (1996). The effect of recombination on background selection. Genetical Research, 67(2), 159-174. https://doi.org/10.1017/S0016672300033619\nR R Hudson and N L Kaplan. Deleterious background selection with recombination. Genetics December 1, 1995 vol. 141 no. 4 1605-1617.\nLinkage and the limits to natural selection. N H Barton. Genetics June 1, 1995 vol. 140 no. 2 821-841\nThornton, K.R. Automating approximate Bayesian computation by local linear regression. BMC Genet 10, 35 (2009). https://doi.org/10.1186/1471-2156-10-35","category":"page"}]
}
